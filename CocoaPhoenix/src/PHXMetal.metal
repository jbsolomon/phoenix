//
//  PHXMetal.metal
//  CocoaPhoenix
//
//  Created by Bodie Solomon on 5/3/19.
//

#include <metal_stdlib>

#import "cocoa_phx/PHXShaders.h"

// Vertex shader outputs and per-fragment inputs.  Includes clip-space position
// and vertex outputs interpolated by the rasterizer and fed to each fragment
// generated by clip-space primitives.
typedef struct
{
    // The [[position]] attribute qualifier of this member indicates this value
    // is in clip space.
    float4 clipSpacePosition [[position]];
    
    // Since this member has no attribute qualifier, the rasterizer will
    // interpolate its value with values of other vertices in the triangle,
    // passing a different value for each fragment in the fragment shader.
    float2 textureCoordinate;
} VertexPosition;

// Vertex shader function
vertex VertexPosition
vertexShader (uint vertexID [[ vertex_id ]],
              constant PHXVertex *vertexArray [[buffer(PHXVertexInputIndexVertices) ]],
              constant vector_uint2 *viewportSizePointer [[ buffer(PHXVertexInputIndexViewportSize) ]])
{
    VertexPosition out;
    
    // Index into our array of positions to get the current vertex, in pixels.
    float2 pixelSpacePosition = vertexArray[vertexID].position.xy;
    
    // Get the size of the drawable so that we can convert to normalized device
    // coordinates.
    float2 viewportSize = float2(*viewportSizePointer);
    
    // The output position of every vertex shader is in clip space, so
    // (-1.0, -1.0) represents the lower-left, and (1.0, 1.0) the upper-right.
    
    // Convert from clip space to viewport space.
    out.clipSpacePosition.xy = pixelSpacePosition / (viewportSize / 2.0);
    
    // No z-dimension since this is all 2D.
    out.clipSpacePosition.z = 0.0;
    
    // No perspective divide required.
    out.clipSpacePosition.w = 1.0;
    
    // Pass the coordinate straight to the rasterizer.
    out.textureCoordinate = vertexArray[vertexID].textureCoordinate;
    
    return out;
}

// Fragment shader function
fragment float4
fragmentShader (VertexPosition in [[ stage_in ]],
                metal::texture2d<half> colorTexture [[ texture(PHXTextureIndexOutput) ]])
{
    constexpr metal::sampler textureSampler (metal::mag_filter::linear,
                                             metal::mag_filter::linear);
    
    // Sample the texture and assign the resulting color to colorSample.
    const half4 colorSample = colorTexture.sample(textureSampler, in.textureCoordinate);
    
    // Return the color of the sampled triangle directly.
    return float4(colorSample);
}
